<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Scope Alt–Az (Gyro+Gravity, 2-Star)</title>
<style>
  :root { color-scheme: dark; }
  body { margin:0; background:#000; color:#f33; font-family: system-ui,-apple-system,Segoe UI,Roboto,sans-serif; }
  .wrap{ padding:18px 20px; max-width:720px; margin:0 auto; }
  h1{ color:#888; font:600 14px/1 system-ui; letter-spacing:.08em; text-transform:uppercase; margin:0 0 12px; }
  .readout{ font:700 44px/1.15 ui-rounded, system-ui, sans-serif; letter-spacing:.5px; }
  .mono{ font-variant-numeric: tabular-nums; }
  .row{ display:flex; gap:12px; flex-wrap:wrap; align-items:end; }
  label{ display:block; color:#888; font-size:12px; margin-bottom:6px; }
  input{ width:150px; padding:8px 10px; border-radius:8px; border:1px solid #333; background:#111; color:#f33; font-weight:600; }
  button{ padding:10px 14px; border:0; border-radius:10px; background:#f33; color:#000; font-weight:800; cursor:pointer; }
  button.secondary{ background:#222; color:#ddd; border:1px solid #333; }
  .help{ color:#888; font-size:12px; margin-top:8px; }
  hr{ border:0; border-top:1px solid #222; margin:14px 0; }
  .debug{ color:#666; font:12px/1.2 ui-monospace, SFMono-Regular, Menlo, monospace; margin-top:8px;}
  .chip{ border:1px solid #333; background:#111; color:#bbb; border-radius:8px; padding:6px 10px; }
</style>
</head>
<body>
<div class="wrap">
  <h1>Scope Alt–Az</h1>

  <div class="readout mono" id="readout">Alt —.—°<br/>Az  —.—°</div>

  <div class="help" id="alignInfo">Align two stars ≥30° apart (avoid near-zenith). Residuals will show after Star B.</div>

  <hr/>

  <div class="row">
    <div>
      <label for="altA">Star A Alt (°)</label>
      <input id="altA" type="text" inputmode="decimal" placeholder="e.g. 35.2">
    </div>
    <div>
      <label for="azA">Star A Az (°)</label>
      <input id="azA" type="text" inputmode="decimal" placeholder="e.g. 127.9">
    </div>
    <button id="alignA">Align A</button>
    <span class="chip" id="stateA">A: —</span>
  </div>

  <div class="row" style="margin-top:10px">
    <div>
      <label for="altB">Star B Alt (°)</label>
      <input id="altB" type="text" inputmode="decimal" placeholder="e.g. 12° 18'">
    </div>
    <div>
      <label for="azB">Star B Az (°)</label>
      <input id="azB" type="text" inputmode="decimal" placeholder="e.g. 250.3">
    </div>
    <button id="alignB">Align B</button>
    <span class="chip" id="stateB">B: —</span>
  </div>

  <div class="row" style="margin-top:10px">
    <button id="enableBtn" class="secondary">Enable Motion Sensors</button>
    <button id="resetBtn" class="secondary">Reset Alignment</button>
    <span class="chip" id="residuals">Residuals: —</span>
  </div>

  <div class="help" id="status">
    Mount the phone rigidly anywhere on the OTA. Tap <b>Enable Motion Sensors</b>, point to Star A, enter Alt/Az from your planetarium app, then tap <b>Align A</b>. Repeat for Star B.
  </div>
  <div class="debug" id="dbg">dt — ms · |g| — m/s² · ωx/ωy/ωz — °/s</div>
</div>

<script>
/* =========================================================
   ORIENTATION (GYRO + GRAVITY) — COMPLEMENTARY FILTER
   - No magnetometer used (goodbye jittery azimuth).
   - Integrate gyro at ~60 Hz, correct pitch/roll with gravity.
   ========================================================= */

const TWO_PI = Math.PI * 2;

// Quaternion as [x,y,z,w]; world frame ENU (x=E, y=N, z=Up)
let qWD = [0,0,0,1]; // device -> world

// Complementary filter gains (tweak if needed)
const KP_ACC = 2.0;      // proportional gain for accel correction (pitch/roll)
const MAX_DT  = 0.05;    // clamp dt (s) to avoid big jumps when tab resumes

let lastT = null;

// Alignment state
let haveA = false, haveB = false, haveOffset = false;
let vDeviceAxis = [1,0,0];        // learned OTA axis in device frame
let m1 = null, m2 = null;         // measured world vectors
let t1 = null, t2 = null;         // true world vectors
let R_offset = identity3();

// Display smoothing
let emaAlt = null, emaAz = null, kSmooth = 0.18;

// Debug
const dbgEl = document.getElementById('dbg');
const statusEl = document.getElementById('status');
const residEl = document.getElementById('residuals');
const stateAEl = document.getElementById('stateA');
const stateBEl = document.getElementById('stateB');

// Permissions / listeners
document.getElementById('enableBtn').addEventListener('click', enableSensors);
document.getElementById('resetBtn').addEventListener('click', resetAlignment);
document.getElementById('alignA').addEventListener('click', doAlignA);
document.getElementById('alignB').addEventListener('click', doAlignB);

// iOS permission flow
async function enableSensors(){
  try{
    if (!window.isSecureContext) throw new Error('Use https (GitHub Pages is https).');

    if (typeof DeviceMotionEvent !== 'undefined' &&
        typeof DeviceMotionEvent.requestPermission === 'function') {
      const r1 = await DeviceMotionEvent.requestPermission();
      if (r1 !== 'granted') throw new Error('Motion permission denied.');
    }
    if (typeof DeviceOrientationEvent !== 'undefined' &&
        typeof DeviceOrientationEvent.requestPermission === 'function') {
      const r2 = await DeviceOrientationEvent.requestPermission();
      if (r2 !== 'granted') throw new Error('Orientation permission denied.');
    }

    attachMotion();
    statusEl.textContent = 'Sensors enabled. If numbers are frozen, enable “Motion & Orientation Access” in Settings → Safari.';
  }catch(e){
    statusEl.textContent = 'Could not enable sensors: ' + e.message;
  }
}

function attachMotion(){
  window.addEventListener('devicemotion', onMotion, true);
  document.addEventListener('visibilitychange', () => { lastT = null; }, true);
}

// Main motion handler (gyro+acc fusion)
function onMotion(ev){
  // Gyro (deg/s) about device axes: alpha=z, beta=x, gamma=y
  const rr = ev.rotationRate || {};
  let wx = (rr.beta  || 0) * Math.PI/180; // x rad/s
  let wy = (rr.gamma || 0) * Math.PI/180; // y rad/s
  let wz = (rr.alpha || 0) * Math.PI/180; // z rad/s

  // dt
  const tNow = ev.timeStamp ? ev.timeStamp/1000 : performance.now()/1000;
  let dt = (lastT == null) ? 0 : (tNow - lastT);
  lastT = tNow;
  if (dt <= 0 || dt > MAX_DT) dt = MAX_DT; // clamp (resume / background)

  // Accelerometer incl. gravity (device frame)
  let ag = ev.accelerationIncludingGravity;
  let gx = ag ? ag.x || 0 : 0;
  let gy = ag ? ag.y || 0 : 0;
  let gz = ag ? ag.z || 0 : 0;

  // Normalize measured gravity in device frame (down ~ +? depends on handset; we only use direction)
  let gDev = norm3([gx, gy, gz]);
  // Expected gravity in device frame from current qWD: world gravity = [0,0,-1]
  let gWorld = [0,0,-1];
  let gEstDev = qInvAct(qWD, gWorld);

  // Error between measured and expected gravity (device frame)
  // Using cross product -> rotation axis that would align gEstDev to gDev
  let e = cross(gEstDev, gDev); // sign chosen to damp error
  // Apply proportional correction to gyro (Mahony-style)
  wx += KP_ACC * e[0];
  wy += KP_ACC * e[1];
  wz += KP_ACC * e[2];

  // Integrate gyro: q_dot = 0.5 * q ⊗ [wx,wy,wz,0]
  const halfdt = 0.5 * dt;
  const omega = [wx, wy, wz, 0];
  const qdot = qMul(qWD, omega);
  qWD = normalizeQ([ qWD[0] + qdot[0]*halfdt,
                     qWD[1] + qdot[1]*halfdt,
                     qWD[2] + qdot[2]*halfdt,
                     qWD[3] + qdot[3]*halfdt ]);

  // Live readout
  updateReadout(rr, ag);
}

/* ----------------- ALIGNMENT ACTIONS ----------------- */

function doAlignA(){
  const alt = parseAngle(document.getElementById('altA').value);
  const az  = parseAngle(document.getElementById('azA').value);
  if (!isFinite(alt) || !isFinite(az)) return;

  // True world direction of Star A
  t1 = altAzToUnit(alt, az);

  // Learn device axis from Star A: v_device = q^{-1} ⊗ t_world ⊗ q
  vDeviceAxis = qInvAct(qWD, t1);
  vDeviceAxis = norm3(vDeviceAxis);

  // Measured world vector (should be close to t1 already)
  m1 = qAct(qWD, vDeviceAxis);

  haveA = true; haveOffset = false;
  stateAEl.textContent = 'A: ✓';
  statusEl.textContent = 'Star A locked. Slew to Star B (≥30° away), enter Alt/Az, then Align B.';
}

function doAlignB(){
  if (!haveA) { statusEl.textContent = 'Do Align A first.'; return; }
  const alt = parseAngle(document.getElementById('altB').value);
  const az  = parseAngle(document.getElementById('azB').value);
  if (!isFinite(alt) || !isFinite(az)) return;

  // True world direction of Star B
  t2 = altAzToUnit(alt, az);

  // Current measured pointing (world) with learned device axis
  m2 = qAct(qWD, vDeviceAxis);

  // Build frames and solve R_offset = T * M^T
  const M = makeFrame(m1, m2);
  const T = makeFrame(t1, t2);
  R_offset = mul3x3(T, transpose3(M));
  haveB = true; haveOffset = true;
  stateBEl.textContent = 'B: ✓';

  // Residuals
  const r1 = angleBetween( mulMatVec(R_offset, m1), t1 );
  const r2 = angleBetween( mulMatVec(R_offset, m2), t2 );
  residEl.textContent = `Residuals: ${r1.toFixed(2)}°, ${r2.toFixed(2)}°`;
  statusEl.textContent = 'Two-star alignment complete. Readout corrected.';
}

function resetAlignment(){
  haveA = haveB = haveOffset = false;
  vDeviceAxis = [1,0,0];
  m1 = m2 = t1 = t2 = null;
  R_offset = identity3();
  emaAlt = emaAz = null;
  stateAEl.textContent = 'A: —';
  stateBEl.textContent = 'B: —';
  residEl.textContent  = 'Residuals: —';
  statusEl.textContent = 'Alignment reset. Do Star A, then Star B.';
}

/* ----------------- READOUT ----------------- */

function updateReadout(rr, ag){
  // Current raw pointing in world frame from learned device axis
  const vWorldRaw = qAct(qWD, vDeviceAxis);
  // Apply two-star offset if we have it
  const vWorld = haveOffset ? mulMatVec(R_offset, vWorldRaw) : vWorldRaw;

  const alt = Math.asin(clamp(vWorld[2], -1, 1));
  let az    = Math.atan2(vWorld[0], vWorld[1]); if (az < 0) az += TWO_PI;

  let altD = rad2deg(alt), azD = rad2deg(az);

  if (emaAlt == null){ emaAlt = altD; emaAz = azD; }
  else {
    emaAlt = emaAlt + kSmooth*(altD - emaAlt);
    let d = azD - emaAz; if (d > 180) d -= 360; if (d < -180) d += 360;
    emaAz = emaAz + kSmooth*d; if (emaAz < 0) emaAz += 360; if (emaAz >= 360) emaAz -= 360;
  }

  document.getElementById('readout').innerHTML =
    `Alt ${emaAlt.toFixed(2)}°<br/>Az  ${emaAz.toFixed(2)}°`;

  // Debug line
  const gmag = ag ? Math.hypot(ag.x||0, ag.y||0, ag.z||0).toFixed(2) : '—';
  const dtms = lastT ? (MAX_DT*1000).toFixed(0) : '—';
  const wx = rr && rr.beta  != null ? rr.beta.toFixed(1)  : '—';
  const wy = rr && rr.gamma != null ? rr.gamma.toFixed(1) : '—';
  const wz = rr && rr.alpha != null ? rr.alpha.toFixed(1) : '—';
  dbgEl.textContent = `|g| ${gmag} m/s² · ωx/ωy/ωz ${wx}/${wy}/${wz} °/s`;
}

/* ----------------- MATH HELPERS ----------------- */

function deg2rad(d){ return d * Math.PI/180; }
function rad2deg(r){ return r * 180/Math.PI; }
function clamp(x,a,b){ return Math.min(Math.max(x,a),b); }

function norm3(v){ const m = Math.hypot(v[0],v[1],v[2]) || 1; return [v[0]/m, v[1]/m, v[2]/m]; }
function dot(a,b){ return a[0]*b[0]+a[1]*b[1]+a[2]*b[2]; }
function cross(a,b){ return [ a[1]*b[2]-a[2]*b[1], a[2]*b[0]-a[0]*b[2], a[0]*b[1]-a[1]*b[0] ]; }
function angleBetween(a,b){ const c = clamp(dot(norm3(a),norm3(b)), -1, 1); return rad2deg(Math.acos(c)); }

function altAzToUnit(altDeg, azDeg){
  const alt = deg2rad(altDeg), az = deg2rad(azDeg);
  return norm3([ Math.cos(alt)*Math.sin(az),  // East
                 Math.cos(alt)*Math.cos(az),  // North
                 Math.sin(alt) ]);            // Up
}

// Parse "-5.2" or "34°12'18\"" or "34 12 18"
function parseAngle(s){
  if (!s) return NaN;
  s = s.trim();
  const dms = s.match(/^(-?\d+)(?:[°\s]+(\d+))?(?:['\s]+(\d+(?:\.\d+)?))?["]?\s*$/);
  if (dms){
    const d = parseFloat(dms[1]), m = dms[2] ? parseFloat(dms[2]) : 0, sec = dms[3] ? parseFloat(dms[3]) : 0;
    const sign = d < 0 ? -1 : 1;
    return d + sign*(m/60) + sign*(sec/3600);
  }
  return parseFloat(s);
}

/* ---- 3x3 matrices (column-major like bases) ---- */
function identity3(){ return [1,0,0, 0,1,0, 0,0,1]; }
function transpose3(M){ return [M[0],M[3],M[6], M[1],M[4],M[7], M[2],M[5],M[8]]; }
function mul3x3(A,B){
  const C = new Array(9);
  for(let r=0;r<3;r++){
    for(let c=0;c<3;c++){
      C[r*3+c] = A[r*3+0]*B[0*3+c] + A[r*3+1]*B[1*3+c] + A[r*3+2]*B[2*3+c];
    }
  }
  return C;
}
function mulMatVec(M,v){
  return [
    M[0]*v[0] + M[1]*v[1] + M[2]*v[2],
    M[3]*v[0] + M[4]*v[1] + M[5]*v[2],
    M[6]*v[0] + M[7]*v[1] + M[8]*v[2],
  ];
}

// Build orthonormal frame from two non-colinear unit vectors
function makeFrame(a,b){
  const e1 = norm3(a);
  const bProj = [ b[0] - e1[0]*dot(e1,b),
                  b[1] - e1[1]*dot(e1,b),
                  b[2] - e1[2]*dot(e1,b) ];
  let e2 = norm3(bProj);
  // If nearly colinear, perturb slightly to avoid NaN
  if (!isFinite(e2[0])) {
    e2 = norm3([e1[1], -e1[0], 0.0001]);
  }
  const e3 = cross(e1, e2);
  // Columns = basis vectors
  return [ e1[0], e2[0], e3[0],
           e1[1], e2[1], e3[1],
           e1[2], e2[2], e3[2] ];
}

/* ---- Quaternions [x,y,z,w] ---- */
function qMul(a,b){
  return [
    a[3]*b[0] + a[0]*b[3] + a[1]*b[2] - a[2]*b[1],
    a[3]*b[1] - a[0]*b[2] + a[1]*b[3] + a[2]*b[0],
    a[3]*b[2] + a[0]*b[1] - a[1]*b[0] + a[2]*b[3],
    a[3]*b[3] - a[0]*b[0] - a[1]*b[1] - a[2]*b[2]
  ];
}
function qConj(q){ return [-q[0],-q[1],-q[2], q[3]]; }
function normalizeQ(q){ const n = Math.hypot(q[0],q[1],q[2],q[3])||1; return [q[0]/n,q[1]/n,q[2]/n,q[3]/n]; }
function qAct(q, v){ const t=qMul(q,[v[0],v[1],v[2],0]); const r=qMul(t,qConj(q)); return [r[0],r[1],r[2]]; }
function qInvAct(q, v){ const qc=qConj(q); const t=qMul(qc,[v[0],v[1],v[2],0]); const r=qMul(t,q); return [r[0],r[1],r[2]]; }
</script>
</body>
</html>

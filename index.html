<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Scope Alt-Az</title>
<style>
  :root { color-scheme: dark; }
  body { margin: 0; background:#000; color:#f33; font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; }
  .wrap { padding: 18px 20px; max-width: 680px; margin: 0 auto; }
  h1 { color:#888; font-size: 14px; font-weight: 600; margin: 0 0 12px; letter-spacing:.08em; text-transform: uppercase; }
  .readout { font: 700 44px/1.15 ui-rounded, system-ui, sans-serif; letter-spacing:.5px; }
  .mono { font-variant-numeric: tabular-nums; }
  .row { display:flex; gap:12px; flex-wrap: wrap; align-items:end; }
  label { display:block; color:#888; font-size:12px; margin-bottom:6px; }
  input { width:120px; padding:8px 10px; border-radius:8px; border:1px solid #333; background:#111; color:#f33; font-weight:600; }
  button { padding:10px 14px; border:0; border-radius:10px; background:#f33; color:#000; font-weight:800; cursor:pointer; }
  button.secondary { background:#222; color:#ddd; border:1px solid #333; }
  .help { color:#888; font-size:12px; margin-top:8px; }
  hr { border:0; border-top:1px solid #222; margin:14px 0; }
</style>
</head>
<body>
<div class="wrap">
  <h1>Scope Alt–Az</h1>

  <div class="readout mono" id="readout">Alt —.—°<br/>Az  —.—°</div>

  <hr/>

  <div class="row">
    <div>
      <label for="alt">Known Alt (°)</label>
      <input id="alt" inputmode="decimal" placeholder="e.g. 34.2">
    </div>
    <div>
      <label for="az">Known Az (°)</label>
      <input id="az" inputmode="decimal" placeholder="e.g. 127.9">
    </div>
    <button id="alignBtn">Align</button>
    <button id="reAlignBtn" class="secondary">Re-align</button>
  </div>

  <div class="row" style="margin-top:10px">
    <button id="enableBtn" class="secondary">Enable Motion Sensors</button>
  </div>

  <div class="help" id="status">
    Center a known object, paste its Alt/Az here, tap <b>Align</b>. Then move the scope and watch the numbers.
  </div>
</div>

<script>
/*
  HOW THIS WORKS (short):
  - We read browser orientation Euler angles (alpha,beta,gamma).
  - Build a rotation matrix R_world<-device (approx per spec order Z-X-Y).
  - On Align: compute the device-fixed axis that maps to the entered sky vector.
  - Then each frame: v_world = R * learnedAxis -> Alt/Az readout.
  - No magnetometer required for absolute north because alignment provides it.
  - Re-align occasionally to clamp drift on some devices.
*/

// --- state ---
let aligned = false;
// learned device-axis (unit vector in device coords) that equals optical axis
let vDeviceAxis = [1,0,0]; // default +X until aligned

// simple low-pass for display
let emaAlt = null, emaAz = null, alphaS = 0.18;

// current orientation euler (deg)
let euler = {alpha: 0, beta: 0, gamma: 0}; // z, x, y (per DeviceOrientationEvent)

// request permission on iOS
document.getElementById('enableBtn').addEventListener('click', async () => {
  const status = document.getElementById('status');
  try {
    if (typeof DeviceMotionEvent !== 'undefined' && typeof DeviceMotionEvent.requestPermission === 'function') {
      const resp1 = await DeviceMotionEvent.requestPermission();
      // Some iOS versions gate orientation on DeviceOrientationEvent.requestPermission instead:
      if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
        const resp2 = await DeviceOrientationEvent.requestPermission();
        if (resp1 !== 'granted' || resp2 !== 'granted') throw new Error('Permission denied');
      } else if (resp1 !== 'granted') {
        throw new Error('Permission denied');
      }
    }
    startListeners();
    status.textContent = 'Sensors enabled. If numbers are frozen, try toggling motion/orientation access in iOS Settings > Safari.';
  } catch (e) {
    status.textContent = 'Could not enable sensors: ' + e.message;
  }
});

// align buttons
document.getElementById('alignBtn').addEventListener('click', () => {
  const alt = parseFloat(document.getElementById('alt').value);
  const az  = parseFloat(document.getElementById('az').value);
  if (!isFinite(alt) || !isFinite(az)) return;
  // build world vector from entered Alt/Az
  const tWorld = altAzToUnit(alt, az); // ENU
  // R_world<-device from current euler
  const R = eulerToR(euler.alpha, euler.beta, euler.gamma);
  // v_device = R^{-1} * t_world  (since v_world = R * v_device)
  const vDev = mulMatVec(transpose3(R), tWorld);
  vDeviceAxis = norm3(vDev);
  aligned = true;
  emaAlt = null; emaAz = null;
  document.getElementById('status').textContent = 'Aligned. Move the scope.';
});

document.getElementById('reAlignBtn').addEventListener('click', () => {
  aligned = false;
  document.getElementById('status').textContent = 'Re-alignment pending. Center a known object and press Align.';
});

// start listeners immediately (will work on desktop / some Android without explicit permission)
startListeners();

// --- sensor listeners ---
function startListeners() {
  window.addEventListener('deviceorientation', (ev) => {
    // alpha (z-yaw), beta (x-tilt), gamma (y-tilt) in degrees
    // Some browsers provide ev.absolute; we don't rely on it due to one-star align.
    if (ev.alpha == null || ev.beta == null || ev.gamma == null) return;
    euler.alpha = ev.alpha;
    euler.beta  = ev.beta;
    euler.gamma = ev.gamma;
    updateReadout();
  }, true);
}

// --- math ---

function deg2rad(d){ return d * Math.PI / 180; }
function rad2deg(r){ return r * 180 / Math.PI; }

function norm3(v){
  const m = Math.hypot(v[0], v[1], v[2]) || 1;
  return [v[0]/m, v[1]/m, v[2]/m];
}
function mulMatVec(M, v){
  return [
    M[0]*v[0] + M[1]*v[1] + M[2]*v[2],
    M[3]*v[0] + M[4]*v[1] + M[5]*v[2],
    M[6]*v[0] + M[7]*v[1] + M[8]*v[2]
  ];
}
function transpose3(M){
  return [M[0],M[3],M[6], M[1],M[4],M[7], M[2],M[5],M[8]];
}

// Build R_world<-device from DeviceOrientation Euler (approx Z-X-Y intrinsic)
function eulerToR(alphaDeg, betaDeg, gammaDeg){
  const a = deg2rad(alphaDeg), b = deg2rad(betaDeg), c = deg2rad(gammaDeg);

  // Rz(a)
  const ca = Math.cos(a), sa = Math.sin(a);
  const Rz = [ ca,-sa, 0,
               sa, ca, 0,
                0,  0, 1 ];

  // Rx(b)
  const cb = Math.cos(b), sb = Math.sin(b);
  const Rx = [ 1, 0,  0,
               0, cb,-sb,
               0, sb, cb ];

  // Ry(c)
  const cc = Math.cos(c), sc = Math.sin(c);
  const Ry = [ cc, 0, sc,
                0, 1, 0,
              -sc, 0, cc ];

  // Intrinsic Z-X-Y ≈ Rz * Rx * Ry
  return mul3(Rz, mul3(Rx, Ry));
}

// 3x3 * 3x3
function mul3(A,B){
  const C = new Array(9);
  for (let r=0;r<3;r++){
    for (let c=0;c<3;c++){
      C[r*3+c] = A[r*3+0]*B[0*3+c] + A[r*3+1]*B[1*3+c] + A[r*3+2]*B[2*3+c];
    }
  }
  return C;
}

// ENU vector from Alt/Az (degrees)
function altAzToUnit(altDeg, azDeg){
  const alt = deg2rad(altDeg), az = deg2rad(azDeg);
  const x = Math.cos(alt) * Math.sin(az); // East
  const y = Math.cos(alt) * Math.cos(az); // North
  const z = Math.sin(alt);                // Up
  return norm3([x,y,z]);
}

// display update
function updateReadout(){
  // if not aligned: assume +X as axis so you still see relative motion
  const axis = aligned ? vDeviceAxis : [1,0,0];
  const R = eulerToR(euler.alpha, euler.beta, euler.gamma);
  const vWorld = mulMatVec(R, axis); // ENU

  // Alt/Az from unit vector
  const alt = Math.asin(Math.max(-1, Math.min(1, vWorld[2])));
  let az = Math.atan2(vWorld[0], vWorld[1]); // 0=N, +E

  let altD = rad2deg(alt);
  let azD = rad2deg(az);
  if (azD < 0) azD += 360;

  // EMA smoothing (with wrap for az)
  if (emaAlt == null) { emaAlt = altD; emaAz = azD; }
  else {
    emaAlt = emaAlt + alphaS * (altD - emaAlt);
    emaAz  = smoothWrapDeg(emaAz, azD, alphaS);
  }

  const rd = document.getElementById('readout');
  rd.innerHTML = `Alt ${emaAlt.toFixed(2)}°<br/>Az  ${emaAz.toFixed(2)}°`;
}

function smoothWrapDeg(prev, next, k){
  let d = next - prev;
  if (d > 180) d -= 360;
  if (d < -180) d += 360;
  let out = prev + k*d;
  if (out < 0) out += 360;
  if (out >= 360) out -= 360;
  return out;
}
</script>
</body>
</html>

<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Scope Alt-Az</title>
<style>
  :root { color-scheme: dark; }
  body { margin:0; background:#000; color:#f33; font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; }
  .wrap{ padding:18px 20px; max-width:680px; margin:0 auto; }
  h1{ color:#888; font-size:14px; font-weight:600; margin:0 0 12px; letter-spacing:.08em; text-transform:uppercase; }
  .readout{ font:700 44px/1.15 ui-rounded, system-ui, sans-serif; letter-spacing:.5px; }
  .mono{ font-variant-numeric: tabular-nums; }
  .row{ display:flex; gap:12px; flex-wrap:wrap; align-items:end; }
  label{ display:block; color:#888; font-size:12px; margin-bottom:6px; }
  /* NOTE: type="text" so iOS allows minus sign; inputmode shows decimal keypad */
  input{ width:140px; padding:8px 10px; border-radius:8px; border:1px solid #333; background:#111; color:#f33; font-weight:600; }
  button{ padding:10px 14px; border:0; border-radius:10px; background:#f33; color:#000; font-weight:800; cursor:pointer; }
  button.secondary{ background:#222; color:#ddd; border:1px solid #333; }
  .help{ color:#888; font-size:12px; margin-top:8px; }
  hr{ border:0; border-top:1px solid #222; margin:14px 0; }
</style>
</head>
<body>
<div class="wrap">
  <h1>Scope Alt–Az</h1>

  <div class="readout mono" id="readout">Alt —.—°<br/>Az  —.—°</div>

  <hr/>

  <div class="row">
    <div>
      <label for="alt">Known Alt (°)</label>
      <input id="alt" type="text" inputmode="decimal" placeholder="e.g. -5.2">
    </div>
    <div>
      <label for="az">Known Az (°)</label>
      <input id="az" type="text" inputmode="decimal" placeholder="e.g. 127.9">
    </div>
    <button id="alignBtn">Align</button>
    <button id="reAlignBtn" class="secondary">Re-align</button>
  </div>

  <div class="row" style="margin-top:10px">
    <button id="enableBtn" class="secondary">Enable Motion Sensors</button>
  </div>

  <div class="help" id="status">
    Center a known object, paste its Alt/Az here (decimals; negatives OK), tap <b>Align</b>. Then move the scope and watch the numbers.
  </div>
</div>

<script>
/* ---------------------------------------------------------
   WHY THIS VERSION FIXES YOUR ISSUES
   - Inputs accept "-" (type=text + custom parsing).
   - Orientation uses quaternion math w/ screen-orientation
     compensation (no ±45° weirdness).
   --------------------------------------------------------- */

// --- alignment state ---
let aligned = false;
let vDeviceAxis = [1,0,0]; // learned device-fixed optical axis
let emaAlt = null, emaAz = null, kSmooth = 0.18;

// current deviceorientation angles (deg)
let euler = { alpha:0, beta:0, gamma:0 };
// current screen orientation (rad)
let screenOrientRad = getScreenOrientRad();
window.addEventListener('orientationchange', () => {
  screenOrientRad = getScreenOrientRad();
});
if (screen.orientation && 'onchange' in screen.orientation) {
  screen.orientation.addEventListener('change', () => {
    screenOrientRad = getScreenOrientRad();
  });
}

function getScreenOrientRad(){
  const ang = (screen.orientation && screen.orientation.angle != null)
    ? screen.orientation.angle
    : (window.orientation || 0);
  return (ang || 0) * Math.PI/180;
}

// --- permissions + listeners (iOS/Safari robust) ---
const statusEl = document.getElementById('status');
let listenersActive = false;

document.getElementById('enableBtn').addEventListener('click', enableSensors);

async function enableSensors() {
  try {
    if (!window.isSecureContext) {
      throw new Error('Site must be https (GitHub Pages is https).');
    }

    // iOS 13+ style permission prompts (some versions require BOTH)
    if (typeof DeviceMotionEvent !== 'undefined' &&
        typeof DeviceMotionEvent.requestPermission === 'function') {
      const r1 = await DeviceMotionEvent.requestPermission();
      if (r1 !== 'granted') throw new Error('Motion permission denied.');
    }
    if (typeof DeviceOrientationEvent !== 'undefined' &&
        typeof DeviceOrientationEvent.requestPermission === 'function') {
      const r2 = await DeviceOrientationEvent.requestPermission();
      if (r2 !== 'granted') throw new Error('Orientation permission denied.');
    }

    attachOrientationListeners();     // ← only now, inside the gesture
    statusEl.textContent = 'Sensors enabled. Move the scope to see numbers.';

    // sanity timer: if nothing arrives in 2s, suggest Safari setting
    setTimeout(() => {
      if (!listenersActive) return;
      if (lastUpdateTime === 0) {
        statusEl.textContent =
          'Still not receiving sensor data. In Settings → Safari, turn ON “Motion & Orientation Access”, then reload and tap Enable.';
      }
    }, 2000);

  } catch (e) {
    statusEl.textContent = 'Could not enable sensors: ' + e.message;
  }
}

let lastUpdateTime = 0;

function attachOrientationListeners() {
  if (listenersActive) return;
  listenersActive = true;

  // Some iOS versions fire only one of these:
  window.addEventListener('deviceorientation', handleOrientation, true);
  window.addEventListener('deviceorientationabsolute', handleOrientation, true);

  // Wake things back up after tab switches
  document.addEventListener('visibilitychange', () => {
    if (!document.hidden && listenersActive) {
      lastUpdateTime = 0;
    }
  });
}

function handleOrientation(ev) {
  // Ignore null payloads
  if (ev.alpha == null || ev.beta == null || ev.gamma == null) return;

  euler.alpha = ev.alpha;
  euler.beta  = ev.beta;
  euler.gamma = ev.gamma;
  lastUpdateTime = performance.now();
  updateReadout();
}

    status.textContent = 'Sensors enabled.';
  } catch (e) {
    status.textContent = 'Could not enable sensors: ' + e.message;
  }
});

// align / realign
document.getElementById('alignBtn').addEventListener('click', () => {
  const alt = parseAngle(document.getElementById('alt').value);
  const az  = parseAngle(document.getElementById('az').value);
  if (!isFinite(alt) || !isFinite(az)) return;

  const tWorld = altAzToUnit(alt, az); // ENU
  const qWD = getQuaternionWorldFromDevice(euler.alpha, euler.beta, euler.gamma, screenOrientRad);
  const vDev = qInvAct(qWD, tWorld); // v_device = q^{-1} ⊗ t_world ⊗ q
  vDeviceAxis = norm3(vDev);
  aligned = true;
  emaAlt = null; emaAz = null;
  document.getElementById('status').textContent = 'Aligned. Move the scope.';
});

document.getElementById('reAlignBtn').addEventListener('click', () => {
  aligned = false;
  document.getElementById('status').textContent = 'Re-alignment pending. Center a known object and press Align.';
});

// start listeners (works immediately on many Android/desktop)
startListeners();

function startListeners(){
  window.addEventListener('deviceorientation', (ev) => {
    if (ev.alpha == null || ev.beta == null || ev.gamma == null) return;
    euler.alpha = ev.alpha;
    euler.beta  = ev.beta;
    euler.gamma = ev.gamma;
    updateReadout();
  }, true);
}

// ----- math utils -----

function deg2rad(d){ return d * Math.PI / 180; }
function rad2deg(r){ return r * 180 / Math.PI; }
function clamp(x,a,b){ return Math.min(Math.max(x,a),b); }

function norm3(v){
  const m = Math.hypot(v[0],v[1],v[2]) || 1;
  return [v[0]/m, v[1]/m, v[2]/m];
}
function dot(a,b){ return a[0]*b[0]+a[1]*b[1]+a[2]*b[2]; }

// Parse numbers like "-5.2", "34°12'18\"", "34 12 18"
function parseAngle(s){
  if (!s) return NaN;
  s = s.trim();
  // DMS?
  const dms = s.match(/^(-?\d+)(?:[°\s]+(\d+))?(?:['\s]+(\d+(?:\.\d+)?))?["]?\s*$/);
  if (dms){
    const d = parseFloat(dms[1]);
    const m = dms[2] ? parseFloat(dms[2]) : 0;
    const sec = dms[3] ? parseFloat(dms[3]) : 0;
    const sign = d < 0 ? -1 : 1;
    return d + sign*(m/60) + sign*(sec/3600);
  }
  // plain number
  return parseFloat(s);
}

// Alt/Az (deg) -> ENU unit vector
function altAzToUnit(altDeg, azDeg){
  const alt = deg2rad(altDeg), az = deg2rad(azDeg);
  const x = Math.cos(alt) * Math.sin(az); // East
  const y = Math.cos(alt) * Math.cos(az); // North
  const z = Math.sin(alt);                // Up
  return norm3([x,y,z]);
}

// Quaternion helpers (as [x,y,z,w])
function qMul(a,b){
  return [
    a[3]*b[0] + a[0]*b[3] + a[1]*b[2] - a[2]*b[1],
    a[3]*b[1] - a[0]*b[2] + a[1]*b[3] + a[2]*b[0],
    a[3]*b[2] + a[0]*b[1] - a[1]*b[0] + a[2]*b[3],
    a[3]*b[3] - a[0]*b[0] - a[1]*b[1] - a[2]*b[2]
  ];
}
functi

